import * as React from "react"
import { ControlType } from "framer"
import * as geoViewport from "@mapbox/geo-viewport"
import * as geojsonExtent from "geojson-extent"

type Marker = {
    name?: "pin-s" | "pin-l"
    label?: string
    color?: string
    center: [number, number]
}

type CustomMarker = {
    url?: string
    center: [number, number]
}

type Path = {
    strokeWidth?: number
    strokeColor?: string
    strokeOpacity?: number
    fillColor?: string
    fillOpacity?: number
    polyline: string
}

type Viewport = {
    center: [number, number]
    zoom: number
}

interface Props {
    accessToken: string
    height: number
    width: number
    longitude?: number
    latitude?: number
    zoom?: number
    pitch?: number
    bearing?: number
    mapStyle?: string
    retina?: boolean
    geojson?: { [key: string]: any } | string
    path?: Path
    markers?: Marker[]
    customMarkers?: CustomMarker[]
    fitBounds?: boolean
    minZoom?: number
    maxZoom?: number
    padding?: number
    onClick?: (event?: React.MouseEvent<HTMLDivElement>) => void
    onMouseEnter?: (event?: React.MouseEvent<HTMLDivElement>) => void
    onMouseLeave?: (event?: React.MouseEvent<HTMLDivElement>) => void
    onViewportChange?: (viewport: Viewport) => void
}

export class StaticMap extends React.Component<Props> {
    static defaultProps: Props = {
        accessToken: null,
        mapStyle: "light-v9",
        longitude: 83.0769,
        latitude: 13.8462,
        zoom: 2,
        pitch: 0,
        bearing: 0,
        retina: true,
        markers: [],
        customMarkers: [],
        geojson: undefined,
        path: undefined,
        fitBounds: true,
        minZoom: 12,
        maxZoom: 15,
        padding: 32,
        width: 200,
        height: 200,
        onViewportChange: () => null,
    }

    static propertyControls = {
        accessToken: {
            title: "Access Token",
            type: ControlType.String,
        },
        mapStyle: {
            title: "MapStyle",
            type: ControlType.Enum,
            options: [
                "light-v9",
                "dark-v10",
                "streets-v11",
                "outdoors-v11",
                "satellite-v9",
                "satellite-streets-v11",
            ],
            optionTitles: [
                "Light",
                "Dark",
                "Streets",
                "Outdoors",
                "Satellite",
                "Satellite Streets",
            ],
            defaultValue: "light-v9",
        },
        longitude: {
            title: "Longitude",
            type: ControlType.Number,
            min: -90,
            max: 90,
            defaultValue: 83.0769,
            step: 0.001,
        },
        latitude: {
            title: "Latitude",
            type: ControlType.Number,
            min: -180,
            max: 180,
            defaultValue: 13.8462,
            step: 0.001,
        },
        zoom: {
            title: "Zoom",
            type: ControlType.Number,
            min: 0,
            max: 22,
            defaultValue: 2,
            step: 0.01,
        },
        pitch: {
            title: "Pitch",
            type: ControlType.Number,
            min: 0,
            max: 60,
            defaultValue: 0,
            step: 1,
        },
        bearing: {
            title: "Bearing",
            type: ControlType.Number,
            min: -180,
            max: 180,
            defaultValue: 0,
            step: 1,
        },
        retina: {
            title: "Retina",
            type: ControlType.Boolean,
            defaultValue: true,
        },
        geojson: {
            title: "GeoJSON",
            type: ControlType.File,
            allowedFileTypes: ["geojson"],
            defaultValue: null,
        },
        fitBounds: {
            title: "Fit Bounds",
            type: ControlType.Boolean,
            defaultValue: true,
        },
        minZoom: {
            title: "Min Zoom",
            type: ControlType.Number,
            min: 0,
            max: 20,
            defaultValue: 0,
            step: 0.5,
            hidden: ({ fitBounds }) => !fitBounds,
        },
        maxZoom: {
            title: "Max Zoom",
            type: ControlType.Number,
            min: 0,
            max: 20,
            defaultValue: 0,
            step: 0.5,
            hidden: ({ fitBounds }) => !fitBounds,
        },
        padding: {
            title: "Padding",
            type: ControlType.Number,
            min: 0,
            max: 128,
            defaultValue: 32,
            step: 1,
            hidden: ({ fitBounds }) => !fitBounds,
        },
    }

    state = {
        geojson: undefined,
        viewport: {
            center: [this.props.longitude, this.props.latitude],
            zoom: this.props.zoom,
        },
    }

    /* -------------------------------- Lifecycle ------------------------------- */

    componentDidUpdate() {
        this.handleUpdate(this.props)
    }

    componentDidMount() {
        this.handleUpdate(this.props)
    }

    handleUpdate = async (props: Props) => {
        const nextState = await this.calculateViewport(props)
        const [n1, n2] = nextState.viewport.center
        const [p1, p2] = this.state.viewport.center
        const { zoom: nz } = nextState.viewport
        const { zoom: pz } = this.state.viewport

        if (n1 !== p1 || n2 !== p2 || nz !== pz) {
            this.props.onViewportChange(nextState.viewport)
            this.setState(nextState)
        }
    }

    // Turn our props into a viewport
    calculateViewport = async (props: Props) => {
        const {
            width,
            height,
            longitude,
            latitude,
            zoom,
            fitBounds,
            markers,
            customMarkers,
            minZoom,
            maxZoom,
            padding,
            geojson: gjsource,
        } = props

        let viewport: any

        let json = {
            type: "FeatureCollection",
            features: [],
        }

        const geojson = await this.getGeoJson(gjsource)

        const markerFeatures = [...markers, ...customMarkers].map((m, i) => ({
            type: "Feature",
            properties: {},
            geometry: {
                type: "Point",
                coordinates: m.center,
            },
        }))

        if (fitBounds && (geojson || markerFeatures.length > 0)) {
            if (geojson) {
                json = geojson
            }

            if (markerFeatures.length > 0) {
                json.features = [...json.features, ...markerFeatures]
            }

            const bounds = geojsonExtent(json)

            viewport = geoViewport.viewport(
                bounds,
                [width / 2 - padding * 2, height / 2 - padding * 2],
                minZoom,
                maxZoom,
                undefined,
                true
            )
        } else {
            viewport = {
                center: [longitude, latitude],
                zoom,
            }
        }

        return {
            geojson,
            viewport,
        }
    }

    /* ----------------------------- Overlay Methods ---------------------------- */

    // Get an an overlay string for our geojson (object or url)
    getGeoJson = async (geojson: any) => {
        if (!geojson) return

        if (typeof geojson === "string") {
            if (!geojson.includes(".geojson")) {
                return
            }

            const response = await fetch(geojson)
            const data = await response.json()
            return data
        }

        return geojson
    }

    // Get an an overlay string for our path
    getPath = (path: Path) => {
        let withDefaults = {
            strokeWidth: 1,
            strokeColor: "4264fb",
            strokeOpacity: 1,
            fillColor: "4264fb",
            fillOpacity: 0,
            ...path,
        }

        const {
            strokeWidth,
            strokeColor,
            strokeOpacity,
            fillColor,
            fillOpacity,
            polyline,
        } = withDefaults

        return `path-${strokeWidth}+${strokeColor}-${strokeOpacity}+${fillColor}-${fillOpacity}(${polyline})`
    }

    // Get an an overlay string for our markers
    getMarkers = (markers: Marker[]) => {
        return markers
            .map(options => {
                const withDefaults = {
                    name: "pin-s",
                    label: "marker",
                    color: "ff2500",
                    ...options,
                }

                const { name, color, label, center } = withDefaults

                return `${name}-${label}+${color}(${center[0]},${center[1]})`
            })
            .join(",")
    }

    // Get an an overlay string for our custom markers
    getCustomMarkers = (customMarkers: CustomMarker[]) => {
        return customMarkers
            .map(options => {
                const withDefaults = {
                    url: "https%3A%2F%2Fwww.mapbox.com%2Fimg%2Frocket.png",
                    ...options,
                }

                const { url, center } = withDefaults

                return `url-${url}(${center[0]},${center[1]})`
            })
            .join(",")
    }

    /* --------------------------------- Render --------------------------------- */

    render() {
        const {
            accessToken,
            mapStyle,
            markers,
            customMarkers,
            path,
            bearing,
            pitch,
            retina,
            width,
            height,
            onClick,
            onMouseEnter,
            onMouseLeave,
        } = this.props

        const { viewport, geojson } = this.state
        const { center, zoom } = viewport
        const [longitude, latitude] = center

        // Show default view if user hasn't set an access token
        if (!accessToken)
            return (
                <div
                    style={{
                        height: "100%",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        flexDirection: "column",
                        fontSize: 16,
                        fontWeight: 500,
                        padding: 32,
                        color: "#bb88ff",
                        border: "1px solid #8855ff",
                        backgroundColor: "#2f2546",
                        textAlign: "center",
                    }}
                >
                    <p>Add your Mapbox access token.</p>
                    <p>
                        👉{" "}
                        <a
                            style={{ color: "#bb88ff" }}
                            href="https://account.mapbox.com/"
                        >
                            Get yours here.
                        </a>
                    </p>
                </div>
            )

        // Compose overlays
        let overlay = ""
        let overlays = []

        // GeoJSON Overlay
        if (geojson) {
            const geojsonURI = encodeURIComponent(JSON.stringify(geojson))
            overlays.push(`geojson(${geojsonURI})`)
        }

        // Path overlay
        if (path) {
            overlays.push(this.getPath(path))
        }

        // Markers overlay
        if (markers.length > 0) {
            overlays.push(this.getMarkers(markers))
        }

        // Custom markers overlay
        if (customMarkers.length > 0) {
            overlays.push(this.getCustomMarkers(customMarkers))
        }

        // Join up our overlays
        if (overlays.length > 0) {
            overlay = overlays.join(",")
            overlay += "/"
        }

        // Compose our url
        const url =
            `https://api.mapbox.com/styles/v1/mapbox/` +
            `${mapStyle}/static/${overlay}` +
            `${longitude},${latitude},${zoom},${bearing},${pitch}/` +
            `${width}x${height}` +
            `${retina ? "@2x" : ""}` +
            `?access_token=${accessToken}`

        console.log(url)
        return (
            <div
                style={{
                    height: "100%",
                    backgroundColor: "#c9d2d3",
                    backgroundSize: "100%",
                    backgroundPosition: "100%",
                }}
                onClick={onClick}
                onMouseEnter={onMouseEnter}
                onMouseLeave={onMouseLeave}
            >
                <img src={url} style={{ height: "100%", width: "100%" }} />
            </div>
        )
    }
}
